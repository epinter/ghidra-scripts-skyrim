// Renames functions, labels and data using input files from Skyrim Address Library (.rename and offsets.txt).
// To use, you will need skyrimae.rename and offsets text file (like offsets-1.6.1170.0.txt) generated by AddressLibraryManager or the c++ code
// available at the nexus page of Address Library for Skyrim Special Edition.
//
// During rename this script adds labels to assign the functions to the respective classes if they are specified
// in the rename file (assuming the structure is always class::method). If the name doesn't have two
// components, the label is not added.
//
//@category  Skyrim
//@author    epinter

import ghidra.app.script.GhidraScript;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.symbol.*;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.InvalidInputException;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.HashMap;
import java.util.HexFormat;
import java.util.Iterator;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@SuppressWarnings({"unused", "SpellCheckingInspection"})
public class SkyrimRenameFromAddressLibrary extends GhidraScript {
    private final HashMap<Long, String> symbolList = new HashMap<>();
    private static final long BASE = 0x140000000L;
    private static final boolean DEBUG = false;
    private static final boolean IDASCRIPT_MODE = false;

    //overwrite vfunctions found by Ghidra RecoverClassesFromRTTIScript
    private static final boolean OVERWRITE_VFUNC_RTTI = true;

    //when false functions are renamed and namespace will be set, when true additional label is created and function nams is set using namespace
    private static final boolean CREATE_LABEL = false;

    @Override
    protected void run() throws Exception {
        int metricNsCreated = 0;
        int metricLblSet = 0;
        int metricFunNameSet = 0;
        int metricFunLblCreated = 0;
        int metricFunFound = 0;
        int metricSymFound = 0;
        int metricDatFound = 0;
        int metricClassMatch = 0;
        int metricDatLblCreated = 0;
        int metricSymNotFound = 0;

        String fileDescription = currentProgram.getMetadata().get("PE Property[FileDescription]");
        String fileVersion = currentProgram.getMetadata().get("PE Property[FileVersion]");

        if (IDASCRIPT_MODE) {
            File file = askFile(String.format("Select SetNamesInIDA.py script for '%s' version %s", fileDescription, fileVersion), "OK");
            if (file == null || !file.exists() || file.isDirectory()) {
                logError("file not found");
                return;
            }
            readIdaScript(file);
        } else {
            File renameFile = askFile("Select skyrimae.rename file", "OK");
            if (!renameFile.exists() || renameFile.isDirectory()) {
                System.err.println(".rename file not found");
                return;
            }

            File offsetsFile = askFile(String.format("Select offsets file for '%s' version %s", fileDescription, fileVersion), "OK");
            if (!offsetsFile.exists() || offsetsFile.isDirectory()) {
                System.err.println("offsets file not found");
                return;
            }
            readAddressLibrary(renameFile, offsetsFile);
        }
        logInfo("Records found: '%s'", symbolList.size());

        Listing listing = currentProgram.getListing();
        SymbolTable symbolTable = currentProgram.getSymbolTable();

        monitor.initialize(symbolList.size());
        monitor.setShowProgressValue(true);
        monitor.setProgress(1);
        monitor.setCancelEnabled(true);

        int count = 0;
        start();
        for (Map.Entry<Long, String> ent : symbolList.entrySet()) {
            monitor.checkCancelled();
            monitor.incrementProgress();
            if (monitor.isCancelled())
                break;

            HexFormat hex = HexFormat.of();
            String address = String.format("%s", hex.toHexDigits(ent.getKey(), 9).toUpperCase());
            Symbol symbol = getSymbolAt(parseAddress(String.format("%s", hex.toHexDigits(ent.getKey(), 9))));

            if (symbol == null) {
                logError("WARNING: No symbol found at address %s", address);
                metricSymNotFound++;
                Data data = getDataAt(parseAddress(String.format("%s", hex.toHexDigits(ent.getKey(), 9))));
                if (data != null && (data.getLabel() == null || data.getLabel().startsWith("DAT_"))) {
                    logDebug("setting %s data label to %s", address, ent.getValue());
                    createLabel(data.getAddress(), ent.getValue(), currentProgram.getGlobalNamespace(), true, SourceType.IMPORTED);
                    metricDatLblCreated++;
                }
                continue;
            }
            metricSymFound++;

            if (symbol.getSymbolType().equals(SymbolType.FUNCTION)) {
                monitor.setMessage("Processing FUNCTION " + address);
                Function function = listing.getFunctionAt(symbol.getAddress());
                if (function == null) {
                    logError("Function %s not found%n", address);
                    continue;
                }
                metricFunFound++;
                if (function.getName().startsWith("FUN_") || (function.getName().startsWith("vfunction") && OVERWRITE_VFUNC_RTTI)) {
                    String[] names = ent.getValue().split("::");
                    if (names.length == 2) {
                        if (currentProgram.getSymbolTable().getSymbols(names[0], currentProgram.getGlobalNamespace()).isEmpty()) {
                            symbolTable.createClass(currentProgram.getGlobalNamespace(), names[0], SourceType.IMPORTED);
                        }
                        Namespace currentNamespace = symbolTable.getNamespace(names[0], currentProgram.getGlobalNamespace());

                        Iterator<Symbol> classNames = symbolTable.getSymbols(names[0]);
                        while (classNames.hasNext()) {
                            Symbol s = classNames.next();
                            if (s.getSymbolType().equals(SymbolType.CLASS) && s.getName().equals(names[0])) {
                                metricClassMatch++;
                                logDebug("class found " + names[0] + " creating label for address " + symbol.getAddress()
                                        + " namespace " + currentProgram.getGlobalNamespace() + " " + ent.getValue());
                                if (CREATE_LABEL) {
                                    function.setName(ent.getValue(), SourceType.IMPORTED);
                                    Symbol label = createLabel(symbol.getAddress(), names[1], currentNamespace, true, SourceType.IMPORTED);
                                    metricFunLblCreated++;
                                    if (!label.isPrimary()) {
                                        logError("label for address %s not set as primary", address);
                                    }
                                } else {
                                    function.setParentNamespace(currentNamespace);
                                    function.setName(names[1], SourceType.IMPORTED);
                                }
                            }
                        }
                    } else {
                        function.setName(ent.getValue(), SourceType.IMPORTED);
                    }
                    metricFunNameSet++;

                }
            } else if (symbol.getSymbolType().equals(SymbolType.LABEL)) {
                monitor.setMessage("Processing LABEL " + address);
                if (symbol.getName().startsWith("LAB_") || symbol.getName().startsWith("DAT_") || symbol.getName().startsWith("PTR_LAB_")) {
                    String newSymbolName = ent.getValue();
                    if (ent.getValue() != null && ent.getValue().startsWith("?")) {
                        newSymbolName = getDemangled(ent.getValue());
                    }
                    try {
                        symbol.setName(newSymbolName, SourceType.IMPORTED);
                    } catch (InvalidInputException | DuplicateNameException e) {
                        symbol.setName(ent.getValue(), SourceType.IMPORTED);
                    }
                    metricLblSet++;
                    logDebug("setting symbol(label) name '%s' for address %s%n", ent.getValue(), address);
                } else {
                    logDebug("symbol name not set for %s, ('%s')", address, symbol.getName());
                }
            } else {
                logError("Not a function (%s) %s", symbol.getSymbolType(), address);
            }
        }
        end(true);

        logInfo("""
                        \n
                        Namespace created: %s
                        Function name set: %s
                        Function label created: %s
                        Labels set: %s
                        Data label set: %s
                        Class name matches: %s
                        Symbols found: %s
                        Functions found: %s
                        Data found: %s
                        Symbols not found: %s
                        Input list size: %s
                        """, metricNsCreated, metricFunNameSet, metricFunLblCreated, metricLblSet, metricDatLblCreated,
                metricClassMatch, metricSymFound, metricFunFound, metricDatFound, metricSymNotFound,
                symbolList.size());
    }

    private void logError(String format, Object... args) {
        if (args.length > 0) {
            printerr(String.format(format, args));
        } else {
            printerr(format);
        }
    }

    private void logInfo(String format, Object... args) {
        if (args.length > 0) {
            println(String.format(format, args));
        } else {
            println(format);
        }
    }

    private void logDebug(String format, Object... args) {
        if (!DEBUG)
            return;
        logError(format, args);
    }

    private void readIdaScript(File file) throws IOException {
        Pattern patternLineIda = Pattern.compile("^NameAddr\\(0x([^,]*), \"([^\"]*)\"\\)\\s*$");

        for (String line : Files.readAllLines(file.toPath())) {
            Matcher matcherLineIda = patternLineIda.matcher(line);
            if (matcherLineIda.find()) {
                try {
                    symbolList.put(HexFormat.fromHexDigitsToLong(matcherLineIda.group(1)), matcherLineIda.group(2));
                } catch (NumberFormatException e) {
                    logError("error parsing line (%s)", matcherLineIda.group(1));
                }
            }
        }
    }

    private void readAddressLibrary(File renameFile, File offsetsFile) throws IOException {
        Pattern textFilePattern = Pattern.compile("([^\\s]+)[\\s]+(.*)");
        Map<Integer, String> names = new HashMap<>();

        for (String line : Files.readAllLines(renameFile.toPath())) {
            Matcher matcher = textFilePattern.matcher(line);
            if (matcher.find()) {
                try {
                    if (matcher.group(1) == null || matcher.group(2) == null) {
                        continue;
                    }
                    int id = Integer.parseInt(matcher.group(1));
                    String name = matcher.group(2);
                    names.put(id, name);
                } catch (NumberFormatException e) {
                    logError("error parsing line (%s)", matcher.group(1));
                }
            }
        }

        for (String line : Files.readAllLines(offsetsFile.toPath())) {
            Matcher matcher = textFilePattern.matcher(line);
            if (matcher.find()) {
                try {
                    if (matcher.group(1) == null || matcher.group(2) == null) {
                        continue;
                    }
                    int id = Integer.parseInt(matcher.group(1));
                    long offset = HexFormat.fromHexDigitsToLong(matcher.group(2));
                    String name = names.get(id);
                    if (name != null) {
                        name = name.replaceAll("_\\*$", "_" + String.format("%X", BASE + offset));
                        symbolList.put(BASE + offset, name);
                    }
                } catch (NumberFormatException e) {
                    logError("error parsing line (%s %s)", matcher.group(1), matcher.group(2));
                    return;
                }
            }
        }
    }
}
